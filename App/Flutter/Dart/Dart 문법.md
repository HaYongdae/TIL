# Dart 문법

> Flutter를 위한 Dart 문법 정리
>
> [처음 배우는 플러터 - 역 : 유동환, 2020.03] 을 바탕으로 작성



## 00. 목차

1. [다트 언어의 역사](#01.-다트-언어의-역사)

2. [주석/변수/데이터 타입](#02.-주석/변수/데이터 타입)

3. [연산자](#03.-연산자)

4. [조건문과 제어문](#04.-조건문과-제어문)

5. [Final, Const, Static](#05.-final,-const,-static)

6. [함수](#06.-함수)

7. [객체와 클래스](#07.-객체와-클래스)

8. [기본 자료구조](#08.-기본-자료구조)

9. [표준 라이브러리 활용](#09.-표준-라이브러리-활용)



## 01. 다트 언어의 역사										

###### [목차로](#00.-목차)

> 개발사 : 구글 ( Lars Bak, Kasper Lund)
>
> 개발 시기 : 2011년
>
> 초기에는 웹 프로그래밍을 위해 설계되었다.
>
> 다트 1.0 시절 가장 배우기 나쁜 언어로 선정되기도 했다.
>
> 다트 2.0이 업그레이드 되면서 성능이 개선되었다. (개선 사항은 아래와 같다.)
>
> - 문법의 간결성, 핫 리로드를 제공
> - 런타임 성능과 시작 속도 개선
> - 안드로이드, IOS, 웹에 이식 가능
> - 리액티브 지원 ([리엑티브 프로그래밍이란?](https://dev-daddy.tistory.com/25))
> - 사운트 타입 시스템 도입 (var와 dynamic을 이용한 변수 타입의 동적 변환)
> - XML 없이 UI로 코드 구성 (안드로이드 개발과의 차이, 안드로이드 개발에는 레이아웃을 정의하는 active_main.xml, 설정을 정의하는 AndroidManifest.xml, 빌드를 위한 build.gradle이 각각 작성되어 적용되지만, 플러터 프레임워크에서는 빌드를 위한 Pubspec.yarm 하나만 작성된다. 레이아웃과 빌드는 UI 코드를 통해 작성된다.)





## 02. 주석/변수/데이터 타입							

###### [목차로](#00.-목차)

### 	02-1. Dart의 들여쓰기

​				>>  2칸 (UI 위젯 계층이 깊을 때, 4칸은 가독성이 떨어지기 때문)

### 	02-2. Dart의 주석

​				>> 여러 줄 :  /* 여러 줄 */  또는 /// 여러 줄 ///

​				>> 한 줄 :  // 한 줄 

​				>> 단축키 : (안드로이드 스튜디오 주석 단축키는 범위 지정 후 ctrl + /)

### 	02-3. 변수 타입

​				>> int, double, num / bool / String / var, dynamic / List / Set / Map

​				** num 은 int와 double을 모두 포함하는 타입

​				** String은 '텍스트', "텍스트" 둘 다 사용 가능 (권장은 ' 홑따옴표)

​				** var, dynamic 는 C#이나 python처럼 나머지는 자바처럼 사용된다.

​				** var : 우선 타입 없이 선언하고, 추후에 변수가 선언되면 타입 변경 불가

​				** dynamic : 계속 타입을 변경하며 사용 가능







## 03. 연산자														

###### [목차로](#00.-목차)

### 	03-1. 기본 연산자

​				>> 기본 연산자에 대한 설명은 생략 (할당, 산술, 관계, 논리, 삼항 연산자)

​				>> 응용 연산자

| 구분                                                 | 연산자                                | 비고                                                 |
| ---------------------------------------------------- | ------------------------------------- | ---------------------------------------------------- |
| 타입 테스트 연산자                                   | as                                    | 타입을 강제로 형변환 (EX_  변수1 as 변수2 )          |
|                                                      | is 혹은 !is                           | 타입 확인 (EX_  변수1 is 변수2 ) 결과는 bool값       |
| if null 연산자                                       | 식1 ?? 식2                            | 식1이 null이 아니면 식1로 null이면 식2로 반환        |
| <span style="color:red">**케스케이드 연산자**</span> | <span style="color:red">**..**</span> |                                                      |
| 조건적 멤버 접근 연산자                              | ?.                                    | 객체가 null이 아닐 때 멤버값 반환, null이면 null반환 |

** null로 인한 오류가 발생하지 않도록 if null 연산자와 ?. 연산자를 지원하고 있다.

** 케이케이드 연산자는 지속적으로 같은 객체를 통해 메소드를 호출해야할 때, 코드를 축약하기 위해 사용한다. 예를 들면,  클래스1이 가진 메소드가 Method1과 Method2가 있다면

클래스1..Method1..Method2 처럼 클래스1을 한번만 기재하고 연달아서 하위 메소드들을 실행할 수 있다.







## 04. 조건문과 제어문										

###### [목차로](#00.-목차)

###  04-1.  If문

​				>> if( 조건 ) { } ;

###  04-2. For문

​				>> for ( 일회성 변수 in 나열형 변수 ) { } ;

​				>> for (변수타입 변수명 = 초기값; 변수명 < 끝값; 증감식) { };

### 		04-3. while문

​				>> while( 조건 ) { };

​				>> do { } while ( 조건 );

### 		04-4. switch / case문

​				>> switch ( 확인할 변수 ) { case 값 : 실행1; case 값2 : 실행2;}









## 05. final, const, static								

###### [목차로](#00.-목차)

### 		05-1. Final

​					>> final 타입 변수명 = 변수값 선언을 통해 변경 불가능한 상수를 생성

​					** final은 컴파일 후 런타임 과정에서 상수값을 받아 저장한다.

###  05-2. Const

​					>> const 타입 변수명 = 변수값 선언을 통해 변경 불가능한 상수를 생성

​					** const는 컴파일 단계에서부터 상수값을 받아 저장한다.

​					** [final과 const의 차이는?]([https://medium.com/dartlang-korea/dart-final-%EA%B3%BC-const-bc8c6c024ef4](https://medium.com/dartlang-korea/dart-final-과-const-bc8c6c024ef4))

### 		05-3. Static

​					>> Class 내의 변수나 함수를 사용하기 위해서는 new class() 를 선언 후 사용. 

​					>> Static으로 선언된 변수는 new를 통한 create과정 없이 변수를 가져와 사용.

​					<span style="color:red">**추가 내용 작성 필요**</span>







## 06. 함수															

###### [목차로](#00.-목차)

> 반환타입 함수명(변수타입 변수명) 형태로 선언



- Dart Fucntion 특징

  - 중복호출 : 함수의 매개변수로 함수식을 사용할 수 있다.

    - 함수1(함수2)

  - 선택인자(positional optional parameter)

    - 함수 선언 시, 반환타입 함수명( 타입1 매개변수1, [타입2 매개변수2 = 1]) 선언
    - 매개변수2의 자리에 값을 넣어주면 값이 투입, 값이 없으면 default 1이 투입

  - 이름인자(named optional parameter)

    - 함수 선언 시, 반환타입 함수명( 타입1 매개변수1, {타입2 매개변수2 = 1}) 선언
    - 함수 호출 시, 함수명(값1)로 호출하면 디폴트 값 1이 투입
    - 매개변수2에 값을 지정해주려면, 매개변수2이름 : 값2의 키 벨류 형태로 투입

      <span style="color:red">**교재 94page 참조**</span>







## 07. 객체와 클래스

###### [목차로](#00.-목차)

> 자바와 다른 내용 없음. 일반적인 PL의 클래스로 이해하면 된다.



## 08. 기본 자료구조

###### [목차로](#00.-목차)

### 08-1. list

- 선언 방법 : List<list변수타입> list명 = [값1,값2,...]

### 08-2. Set

- 선언 방법:Set<Set변수타입>Set명 = {값1,값2,...}

- Dart의 Set은 Iterator 기능도 포함하고 있다. (for문에서 바로 사용이 가능하다. 보통은 Iterator를 따로 생성해서 쓴다.)

- 보통의 Set 특징

  - Union(합집합), Intersection(교집합), difference(차집합) 등 집합 메소드들을 보유
  - 중복된 데이터를 저장할 수 없다. (데이터의 인덱스를 따로 관리하지 않기 때문)

  

### 08-3. Map

- 선언 방법:Map<변수타입, 변수타입2> Map명 = { Key1 : Value1, Key2 : Value2, ... : ... }
- Map의 <Key : Value> 중 Value자리에는 Class단위도 입력이 가능하다.



## 09. 표준 라이브러리 활용

###### [목차로](#00.-목차)

> Dart는 표준 라이브러리 코드가 OPEN되어 있다.
>
> IDE에서도 <span style="color:red">**Ctrl + B**</span> 를 통해 원천소스를 바로 볼 수 있다.
>
> 코드는 플러터 SDK 경로 \ bin \ cache \ pkg \ sky_engine 아래에 위치한다.

### 09-1 dart : core 패키지

- 따로 선언이 필요없는 바탕 그 자체다.
- 변수, 자료구조, print() 등을 포함한다.

### 09-2 dart : io 패키지

- Consol 입출력, 파일 import 등에 사용된다. (선언 방식 : Import 'dart:io' )
  - stdout.write() : print기능
  - stdin.readLineSync() : consol에 입력받기
  - File file명 = File('경로');로 파일 import
    - filte명.createSync()로 파일 생성 (defualt 경로는 프로젝트 루트)
    - file명.readAsLinesSync()로 읽기 (동기 방식)
    - file명.writeAsStringSync()로 쓰기 (동기 방식)

### 09-3 dart : math 패키지

- 수학과 관련된 패키지 (선언 방식 : import 'dart:math' )
  - max 
  - min
  - sqrt() : 제곱근
  - (max값, 개수) : 난수 생성
  - round



### 09-4 dart : convert 패키지

- Json 파싱을 위해 사용 (선언 방식 : import 'dart:convert' )
  - Json 파일을 String타입의 변수1 에 담은 상태에서
    - Map 변수명 = jsonDecode(변수1) 실행 시,
    - Json의 깊이가 깊다면, Map 구조를 통해 
      - Map 변수명` = 변수명["하위 계층 Key"] 를 통해 반복적으로 받는다.
  - Json 파싱을 통해 Map을 얻거나, 기존의 Map을 보유한 상태에서
    - File('이름.json').writeAsStringSync(jsonEncode(Map명)) 실행 시,
    - json을 업데이트하거나 쓸 수도 있다.